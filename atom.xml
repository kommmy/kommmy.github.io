<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kommmy Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kommmy.github.io/"/>
  <updated>2019-02-12T09:02:40.638Z</updated>
  <id>https://kommmy.github.io/</id>
  
  <author>
    <name>Kommmy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈django项目中前后端分离csrf传递</title>
    <link href="https://kommmy.github.io/2018/10/23/separation/"/>
    <id>https://kommmy.github.io/2018/10/23/separation/</id>
    <published>2018-10-23T08:09:43.000Z</published>
    <updated>2019-02-12T09:02:40.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>回想起来以后有很久没有用到django提供自带的模板功能了，目前公司的项目基本都采用react+web后端的模式，这样做也相对灵活但是也会出现一些问题，比如如何处理csrf以及登录认证的问题。</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>在说之前，先整体屡一下csrf_token生成的过程。<br>首先在中间件的配置中加入django.middleware.csrf.CsrfViewMiddleware，没有这个的话就没有下面的一切了。<br>这个中间件在process_view中主要是用来生成csrf_token，上来会从cookie中获取，如果cookie中没有，会自动生成一个放到request.META[“CSRF_COOKIE”]，源代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">csrf_token = _sanitize_token(</span><br><span class="line">request.COOKIES[settings.CSRF_COOKIE_NAME])</span><br><span class="line"><span class="comment"># Use same token next time</span></span><br><span class="line">request.META[<span class="string">'CSRF_COOKIE'</span>] = csrf_token</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">csrf_token = <span class="keyword">None</span></span><br><span class="line"><span class="comment"># Generate token and store it in the request, so it's</span></span><br><span class="line"><span class="comment"># available to the view.</span></span><br><span class="line">request.META[<span class="string">"CSRF_COOKIE"</span>] = _get_new_csrf_key()</span><br></pre></td></tr></table></figure></p><p>这里注意，如果是POST方法，且cookie中没有csrf_token的话，那后面的逻辑就会直接报403，提示csrf校验失败，所以上来必须是GET请求，让cookie先种下去才可以。<br>接下来看process_response，源代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> request.META.get(<span class="string">"CSRF_COOKIE"</span>) <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line"><span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> request.META.get(<span class="string">"CSRF_COOKIE_USED"</span>, <span class="keyword">False</span>):</span><br><span class="line"><span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the CSRF cookie even if it's already set, so we renew</span></span><br><span class="line"><span class="comment"># the expiry timer.</span></span><br><span class="line">response.set_cookie(settings.CSRF_COOKIE_NAME,</span><br><span class="line">request.META[<span class="string">"CSRF_COOKIE"</span>],</span><br><span class="line">max_age=settings.CSRF_COOKIE_AGE,</span><br><span class="line">domain=settings.CSRF_COOKIE_DOMAIN,</span><br><span class="line">path=settings.CSRF_COOKIE_PATH,</span><br><span class="line">secure=settings.CSRF_COOKIE_SECURE,</span><br><span class="line">httponly=settings.CSRF_COOKIE_HTTPONLY</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>程序会判断CSRF_COOKIE与CSRF_COOKIE_USED是否为空，CSRF_COOKIE这个不用多说，因为有前面process_view的生成，所以正常情况下都是存在的，但是CSRF_COOKIE_USED是怎么设置的呢？<br>答案在django.middleware.csrf.get_token中。这个函数就做了2个事情，一个是将CSRF_COOKIE_USED设置为True，一个是返回request.META.get(“CSRF_COOKIE”, None)。<br>所以如果你想生成csrf_token，前置条件是必须要调用get_token(或者rotate_token)。<br>总结一下：<br>1.必须调用get_token，只有调用它，返回才会设置set-cookie把csrf_token种进去<br>2.前端需要通过form表单或者HTTP_X_CSRFTOKEN头把csrf_token传到后端，然后后端用传过来的值和cookie的值比对，一致就通过。</p><p>接下来说说怎么与前端结合，因为传统模板的模式下，csrf_token会自动渲染进页面，js可以直接拿到页面的值，但是在前后端分离的情况下我们应该怎么做呢？<br>1.先在后端写一个生成csrf_token的接口<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span><span class="params">(request)</span>:</span></span><br><span class="line">    token = django.middleware.csrf.get_token(request)</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">'token'</span>: token&#125;)</span><br></pre></td></tr></table></figure></p><p>2.前端去请求这个接口，拿到token，保存到cookie中，然后post请求需要csrf_token时，直接从cookie中获取即可<br>3.在后端的views中要加入ensure_csrf_cookie装饰器，这个装饰器的作用就是确保这次返回的时候，回把csrf_token再成功的种回去,刷新过期时间，其实如果不加的话并不影响校验。<br>中间件会去验证前端传过来的token和META cookie中的token是否一致，源码逻辑如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> request_csrf_token == <span class="string">""</span>:</span><br><span class="line"><span class="comment"># Fall back to X-CSRFToken, to make things easier for AJAX,</span></span><br><span class="line"><span class="comment"># and possible for PUT/DELETE.</span></span><br><span class="line">request_csrf_token = request.META.get(<span class="string">'HTTP_X_CSRFTOKEN'</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> constant_time_compare(request_csrf_token, csrf_token):</span><br><span class="line"><span class="keyword">return</span> self._reject(request, REASON_BAD_TOKEN)</span><br></pre></td></tr></table></figure></p><p>这样就可以完成前后端分离模式下的csrf_token的传递。</p><p>另外再多说一句登录认证的事情，因为前后端分离，在开发接口前端工程师通常和后端工程师不在一个域下面，所以session-cookie方式登录就不好使了，需要约定token来实现登录认证。<br>另外一种方式是jwt认证(JSON Web Tokens)，前端用账号密码换取jwt，之后的所有请求都带着jwt，即可实现登录认证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;回想起来以后有很久没有用到django提供自带的模板功能了，目前公司的项目基本都采用react+web后端的模式，这样做也相对灵活但是也会出
      
    
    </summary>
    
      <category term="编程" scheme="https://kommmy.github.io/categories/programming/"/>
    
    
      <category term="python" scheme="https://kommmy.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>快速了解Python中的协程</title>
    <link href="https://kommmy.github.io/2018/05/25/async/"/>
    <id>https://kommmy.github.io/2018/05/25/async/</id>
    <published>2018-05-25T08:09:43.000Z</published>
    <updated>2018-05-25T09:18:29.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概要"><a href="#1-概要" class="headerlink" title="1.概要"></a>1.概要</h2><p>相信写过异步IO编程的人肯定对协程不陌生，那么在Python中有没有简单的方式实现协程呢？<br>从Python 3.5开始引入了新的语法async和await，可以非常简单的实现协程同时代码更简洁易读。<br>现在让我们来对比一下使用协程和不使用协程的区别！<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">"Waiting "</span> + str(x))</span><br><span class="line">    time.sleep(x)</span><br><span class="line">    print(<span class="string">f"<span class="subst">&#123;x&#125;</span> seconds"</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">coros = [do_some_work(<span class="number">4</span>), do_some_work(<span class="number">3</span>)]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">result = loop.run_until_complete(asyncio.wait(coros))</span><br></pre></td></tr></table></figure></p><p>上面是一段没有用到协程的代码，运行代码后会发现，虽然函数已经被声明为协程，但是函数内部没有await，所以不会主动切换函数，程序依然是顺序执行，第一个函数sleep了4秒，第二个函数sleep了3秒，总共7秒执行完毕。</p><p>让我们改一行代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#time.sleep(x)</span></span><br><span class="line"><span class="keyword">await</span> asyncio.sleep(x)</span><br></pre></td></tr></table></figure></p><p>将time.sleep换为await asyncio.sleep，这样做的区别就是，await会主动告诉系统，我现在要执行一个IO操作，可以把空闲的cpu让出来，先做后面的事情，这样一来，当执行到sleep的时候，因为是IO操作，所以会自动切到后面的函数，可以近似的理解为两个函数在并行执行，当所有程序执行完用时4秒（以那个用时最长的为准）<br>因为协程是在线程中运行，所以切换函数效率极高，另外需要强调一点的就是，异步IO和并发是两个概念，千万不要混淆。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-概要&quot;&gt;&lt;a href=&quot;#1-概要&quot; class=&quot;headerlink&quot; title=&quot;1.概要&quot;&gt;&lt;/a&gt;1.概要&lt;/h2&gt;&lt;p&gt;相信写过异步IO编程的人肯定对协程不陌生，那么在Python中有没有简单的方式实现协程呢？&lt;br&gt;从Python 3.5开始
      
    
    </summary>
    
      <category term="编程" scheme="https://kommmy.github.io/categories/programming/"/>
    
    
      <category term="python" scheme="https://kommmy.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch终于支持Windows</title>
    <link href="https://kommmy.github.io/2018/04/25/pytorch/"/>
    <id>https://kommmy.github.io/2018/04/25/pytorch/</id>
    <published>2018-04-25T08:39:52.000Z</published>
    <updated>2018-04-25T08:45:02.532Z</updated>
    
    <content type="html"><![CDATA[<p>喜大普奔！从今天起Pytorch正式支持Windows，当然需要Python版本3.5+</p><p>官网地址：<a href="http://pytorch.org/" target="_blank" rel="noopener">http://pytorch.org/</a></p><p><img src="/2018/04/25/pytorch/pytorch.png" alt="pyroch"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;喜大普奔！从今天起Pytorch正式支持Windows，当然需要Python版本3.5+&lt;/p&gt;
&lt;p&gt;官网地址：&lt;a href=&quot;http://pytorch.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://pytorch.org/
      
    
    </summary>
    
      <category term="其他" scheme="https://kommmy.github.io/categories/other/"/>
    
    
      <category term="python" scheme="https://kommmy.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch入门之VAE</title>
    <link href="https://kommmy.github.io/2018/04/11/gan-vae/"/>
    <id>https://kommmy.github.io/2018/04/11/gan-vae/</id>
    <published>2018-04-11T03:37:06.000Z</published>
    <updated>2018-04-11T09:12:09.838Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：<a href="http://www.cnblogs.com/king-lps/p/8477300.html" target="_blank" rel="noopener">http://www.cnblogs.com/king-lps/p/8477300.html</a></p><h3 id="关于Auto-encoder"><a href="#关于Auto-encoder" class="headerlink" title="关于Auto-encoder"></a>关于Auto-encoder</h3><blockquote><p>假设我们的输入是一张图片，Auto-encoder的工作其实是实现了 图片-&gt;向量-&gt;图片 这一过程。就是说给定一张图片编码后得到一个向量，然后将这一向量进行解码后就得到了原始的图片。这个解码后的图片和之前的原图一样吗？不完全一样。因为一般而言，如前所述是从低维隐层中恢复原图。但是Auto-encoder另我们现在能训练任意多的图片，如果我们把这些图片的编码向量存在来，那以后就能通过这些编码向量来重构我们的图像，称之为标准自编码器。可这还不够，如果现在我随机拿出一个很离谱的向量直接另其解码，那解码出来的东西十有八九是无意义的东西。<br><img src="/2018/04/11/gan-vae/auto-encoder.png" alt="auto-encoder"></p></blockquote><h3 id="变分自动编码器VAE-Variational-Auto－encoder"><a href="#变分自动编码器VAE-Variational-Auto－encoder" class="headerlink" title="变分自动编码器VAE(Variational Auto－encoder)"></a>变分自动编码器VAE(Variational Auto－encoder)</h3><blockquote><p>所以我们希望AE编码出的code符合一种分布（eg：高斯混合模型），那么我们就可以从这个高斯分布任意采样出一个code，给这个code解码那么就会生成一张原图类似的图。而这个强迫分布就是VAE与AE的不同之处了。VAE的编码器输出包括两部分：m和σ。其中e是正态分布, c为编码结果。m、e、σ、c的形状一样，都为（batch_size，latent_code_num) 。这个latent_code_num就相当于高斯混合分布的高斯数量。每个高斯都有自己的均值、方差。所以共有latent_code_num个均值、方差。<br><br><br>接下来是VAE的损失函数：由两部分的和组成（bce_loss、kld_loss)。bce_loss即为binary_cross_entropy（二分类交叉熵）损失，即用于衡量原图与生成图片的像素误差。kld_loss即为KL-divergence（KL散度），用来衡量潜在变量的分布和单位高斯分布的差异。<br><img src="/2018/04/11/gan-vae/vae-format.png" alt="auto-encoder"></p></blockquote><a id="more"></a><h3 id="验证VAE与Auto-encoder的差别"><a href="#验证VAE与Auto-encoder的差别" class="headerlink" title="验证VAE与Auto-encoder的差别"></a>验证VAE与Auto-encoder的差别</h3><h5 id="简单的神经网络"><a href="#简单的神经网络" class="headerlink" title="简单的神经网络"></a>简单的神经网络</h5><p>上面介绍了VAE的细节，那么我们现在就来用手写识别数据集测试一下加入了噪声的神经网络，到底比原始的网络有多大提升。</p><p>首先我们先用激活函数为ELU的多层神经网络训练Auto-encoder,损失函数为binary_cross_entropy</p><p>网络结构如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AE</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(VAE,self).__init__()</span><br><span class="line">        <span class="comment"># 编码</span></span><br><span class="line">        self.encode = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">28</span>*<span class="number">28</span>, <span class="number">128</span>), <span class="comment"># 输入图片像素大小是28*28</span></span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(<span class="number">128</span>, <span class="number">64</span>),</span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(<span class="number">64</span>, <span class="number">12</span>),</span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(<span class="number">12</span>, <span class="number">3</span>),   <span class="comment"># 压缩成3个特征</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 解码</span></span><br><span class="line">        self.decode = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">3</span>, <span class="number">12</span>),</span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(<span class="number">12</span>, <span class="number">64</span>),</span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(<span class="number">64</span>, <span class="number">128</span>),</span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(<span class="number">128</span>, <span class="number">28</span>*<span class="number">28</span>),</span><br><span class="line">            nn.Sigmoid(),       <span class="comment"># 激励函数让输出值在 (0, 1)</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure></p><p>因为网络结构非常简单，加上Auto-encoder非常好理解，在这里就不做过多赘述。在训练了10个epoch之后，输入测试样本，查看输出结果<br><img src="/2018/04/11/gan-vae/vae2.png" alt="结果"><br>解码的结果并不是十分理想，数字4看上去和9十分相似而且每个数字也相对模糊，我们再随机输入一些正态分布的数据，看看神经网络对处理位置数据的能力如何？</p><p><img src="/2018/04/11/gan-vae/fake_samples_epoch_010_relu.png" alt="fake-relu"><br>可以看出，对于随机数据，网络几乎没有任何解析能力。</p><h5 id="VAE"><a href="#VAE" class="headerlink" title="VAE"></a>VAE</h5><p>现在我们把网络结构换成CNN，损失函数为binary_cross_entropy+kld，同时加入噪声，看看会有什么变化。</p><p>网络结构如下,只给出差异部分<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VAE</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(VAE,self).__init__()</span><br><span class="line">        <span class="comment"># 输入图片像素 28 x 28</span></span><br><span class="line">        n = <span class="number">64</span></span><br><span class="line">        <span class="comment"># 第一个输入卷积层，加入了批标准化</span></span><br><span class="line">        self.conv1 = nn.Sequential(nn.Conv2d(<span class="number">1</span>,n,kernel_size=<span class="number">4</span>,stride=<span class="number">2</span>,padding=<span class="number">1</span>),</span><br><span class="line">                                 nn.BatchNorm2d(n),</span><br><span class="line">                                 nn.LeakyReLU(<span class="number">0.2</span>,inplace=<span class="keyword">True</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 经过了第一个卷积层，图片变为14 x 14，因为stride=2，所以变小了</span></span><br><span class="line">        self.conv2 = nn.Sequential(nn.Conv2d(n,n*<span class="number">2</span>,kernel_size=<span class="number">4</span>,stride=<span class="number">2</span>,padding=<span class="number">1</span>),</span><br><span class="line">                                 nn.BatchNorm2d(n*<span class="number">2</span>),</span><br><span class="line">                                 nn.LeakyReLU(<span class="number">0.2</span>,inplace=<span class="keyword">True</span>))</span><br><span class="line">        <span class="comment"># 同样经过了第二个卷积层，输入图片变为7 x 7</span></span><br><span class="line">        <span class="comment"># 第三个卷积层根据因为kernel为3，stride为1，padding为1 所以卷积后图片大小不变</span></span><br><span class="line">        self.conv3 = nn.Sequential(nn.Conv2d(n*<span class="number">2</span>,n,kernel_size=<span class="number">3</span>,stride=<span class="number">1</span>,padding=<span class="number">1</span>),</span><br><span class="line">                                 nn.BatchNorm2d(n),</span><br><span class="line">                                 nn.LeakyReLU(<span class="number">0.2</span>,inplace=<span class="keyword">True</span>))</span><br><span class="line">        <span class="comment"># 将卷积结果传入两个全连接层，产生mean和logvar</span></span><br><span class="line">        self.fc11 = nn.Linear(n * <span class="number">7</span> * <span class="number">7</span>, opt.hidden_size)</span><br><span class="line">        self.fc12 = nn.Linear(n * <span class="number">7</span> * <span class="number">7</span>, opt.hidden_size)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 以下为decoder，操作都是encoder的逆向操作，很好理解</span></span><br><span class="line">        self.fc2 = nn.Linear(opt.hidden_size, n * <span class="number">7</span> * <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">        self.deconv1 = nn.Sequential(nn.ConvTranspose2d(n,n,kernel_size=<span class="number">4</span>,stride=<span class="number">2</span>,padding=<span class="number">1</span>),</span><br><span class="line">                                 nn.BatchNorm2d(n),</span><br><span class="line">                                 nn.ReLU())</span><br><span class="line">        <span class="comment"># 14 x 14</span></span><br><span class="line">        self.deconv2 = nn.Sequential(nn.ConvTranspose2d(n,<span class="number">1</span>,kernel_size=<span class="number">4</span>,stride=<span class="number">2</span>,padding=<span class="number">1</span>),</span><br><span class="line">                                 nn.Sigmoid())</span><br><span class="line">        <span class="comment"># 28 x 28</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生噪声</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sampler</span><span class="params">(self, mu, logvar)</span>:</span></span><br><span class="line">        var = logvar.mul(<span class="number">0.5</span>).exp_()</span><br><span class="line">        eps = torch.FloatTensor(var.size()).normal_()</span><br><span class="line">        eps = Variable(eps)</span><br><span class="line">        <span class="keyword">return</span> eps.mul(var).add_(mu)</span><br><span class="line"></span><br><span class="line"><span class="comment"># loss_function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LossFunction</span><span class="params">(out, target, mu, logvar)</span>:</span></span><br><span class="line">    bceloss = bce(out, target)</span><br><span class="line">    kld = mu.pow(<span class="number">2</span>).add_(logvar.exp()).mul_(<span class="number">-1</span>).add_(<span class="number">1</span>).add_(logvar)</span><br><span class="line">    kldloss = torch.sum(kld).mul_(<span class="number">-0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> bceloss + kldloss</span><br></pre></td></tr></table></figure></p><p>在训练了10个epoch之后，输入测试样本，查看输出结果<br><img src="/2018/04/11/gan-vae/vae.png" alt="结果"><br>可以看出解码效果大大提升，我们再随机输入一些正态分布的数据，看看神经网络对处理位置数据的能力如何？</p><p><img src="/2018/04/11/gan-vae/fake_samples_epoch_010.png" alt="结果"><br>在噪声的加入后，对训练结果有了大幅度提升，这正是我们想要得到的。</p><p>代码参考：<a href="https://github.com/sunshineatnoon/Paper-Implementations" target="_blank" rel="noopener">https://github.com/sunshineatnoon/Paper-Implementations</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考文献：&lt;a href=&quot;http://www.cnblogs.com/king-lps/p/8477300.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/king-lps/p/8477300.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于Auto-encoder&quot;&gt;&lt;a href=&quot;#关于Auto-encoder&quot; class=&quot;headerlink&quot; title=&quot;关于Auto-encoder&quot;&gt;&lt;/a&gt;关于Auto-encoder&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;假设我们的输入是一张图片，Auto-encoder的工作其实是实现了 图片-&amp;gt;向量-&amp;gt;图片 这一过程。就是说给定一张图片编码后得到一个向量，然后将这一向量进行解码后就得到了原始的图片。这个解码后的图片和之前的原图一样吗？不完全一样。因为一般而言，如前所述是从低维隐层中恢复原图。但是Auto-encoder另我们现在能训练任意多的图片，如果我们把这些图片的编码向量存在来，那以后就能通过这些编码向量来重构我们的图像，称之为标准自编码器。可这还不够，如果现在我随机拿出一个很离谱的向量直接另其解码，那解码出来的东西十有八九是无意义的东西。&lt;br&gt;&lt;img src=&quot;/2018/04/11/gan-vae/auto-encoder.png&quot; alt=&quot;auto-encoder&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;变分自动编码器VAE-Variational-Auto－encoder&quot;&gt;&lt;a href=&quot;#变分自动编码器VAE-Variational-Auto－encoder&quot; class=&quot;headerlink&quot; title=&quot;变分自动编码器VAE(Variational Auto－encoder)&quot;&gt;&lt;/a&gt;变分自动编码器VAE(Variational Auto－encoder)&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;所以我们希望AE编码出的code符合一种分布（eg：高斯混合模型），那么我们就可以从这个高斯分布任意采样出一个code，给这个code解码那么就会生成一张原图类似的图。而这个强迫分布就是VAE与AE的不同之处了。VAE的编码器输出包括两部分：m和σ。其中e是正态分布, c为编码结果。m、e、σ、c的形状一样，都为（batch_size，latent_code_num) 。这个latent_code_num就相当于高斯混合分布的高斯数量。每个高斯都有自己的均值、方差。所以共有latent_code_num个均值、方差。&lt;br&gt;&lt;br&gt;&lt;br&gt;接下来是VAE的损失函数：由两部分的和组成（bce_loss、kld_loss)。bce_loss即为binary_cross_entropy（二分类交叉熵）损失，即用于衡量原图与生成图片的像素误差。kld_loss即为KL-divergence（KL散度），用来衡量潜在变量的分布和单位高斯分布的差异。&lt;br&gt;&lt;img src=&quot;/2018/04/11/gan-vae/vae-format.png&quot; alt=&quot;auto-encoder&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="https://kommmy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="python" scheme="https://kommmy.github.io/tags/python/"/>
    
      <category term="pytorch" scheme="https://kommmy.github.io/tags/pytorch/"/>
    
  </entry>
  
  <entry>
    <title>手写Python反向传播</title>
    <link href="https://kommmy.github.io/2018/03/30/bptt/"/>
    <id>https://kommmy.github.io/2018/03/30/bptt/</id>
    <published>2018-03-30T06:56:13.000Z</published>
    <updated>2018-04-25T08:38:02.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概要"><a href="#1-概要" class="headerlink" title="1.概要"></a>1.概要</h2><p>本文来自博客 <a href="http://iamtrask.github.io/2015/07/27/python-network-part2/" target="_blank" rel="noopener">A Neural Network in 13 lines of Python</a><br>这篇博客只用了13行代码就实现了Python版本的反向传播，虽然有很多文章都对它进行了翻译，但在最关键反向传播部分，并没有给出详细公式，下面就对代码中的反向传播进行重点介绍。</p><h2 id="2-全部反向传播代码"><a href="#2-全部反向传播代码" class="headerlink" title="2.全部反向传播代码"></a>2.全部反向传播代码</h2><p>下面是13行完整代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">X = np.array([ [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] ])</span><br><span class="line">y = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]]).T</span><br><span class="line">lr,hidden_dim = (<span class="number">0.5</span>,<span class="number">4</span>)</span><br><span class="line">w0 = <span class="number">2</span>*np.random.random((<span class="number">3</span>,hidden_dim)) - <span class="number">1</span></span><br><span class="line">w1 = <span class="number">2</span>*np.random.random((hidden_dim,<span class="number">1</span>)) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">60000</span>):</span><br><span class="line">    layer1 = <span class="number">1</span>/(<span class="number">1</span>+np.exp(-(np.dot(X,w0))))</span><br><span class="line">    layer2 = <span class="number">1</span>/(<span class="number">1</span>+np.exp(-(np.dot(layer1,w1))))</span><br><span class="line">    layer2_delta = (layer2 - y)*(layer2*(<span class="number">1</span>-layer2))</span><br><span class="line">    layer1_delta = layer2_delta.dot(w1.T) * (layer1 * (<span class="number">1</span>-layer1))</span><br><span class="line">    w1 -= (lr * layer1.T.dot(layer2_delta))</span><br><span class="line">    w0 -= (lr * X.T.dot(layer1_delta))</span><br><span class="line">print(layer2)</span><br></pre></td></tr></table></figure></p><h2 id="3-关键行解释"><a href="#3-关键行解释" class="headerlink" title="3.关键行解释"></a>3.关键行解释</h2><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">定义</th></tr></thead><tbody><tr><td style="text-align:left">X</td><td style="text-align:left">输入数据矩阵，每行是一个训练样例</td></tr><tr><td style="text-align:left">y</td><td style="text-align:left">输出数据矩阵，每行是一个训练样例</td></tr><tr><td style="text-align:left">layer1</td><td style="text-align:left">神经网络的隐含层，输入来自X</td></tr><tr><td style="text-align:left">layer2</td><td style="text-align:left">神经网络的输出层，输入来自layer1</td></tr><tr><td style="text-align:left">w1</td><td style="text-align:left">输出层权重，连接layer1与layer2</td></tr><tr><td style="text-align:left">w0</td><td style="text-align:left">隐含层权重，连接X与layer1</td></tr></tbody></table><p><strong>line1-6:</strong> 前6行都是在定义初始化参数，学习率和权重矩阵等等，这些应该很好理解。<br><strong>line8-9:</strong> 这两行是在进行前向传播，激活函数为sigmoid。<br><strong>line10-13:</strong> 这四行是在进行反向传播，下面来说说代码为什么这么写<br><a id="more"></a><br>首先整体误差:</p><p>$E_{total}=\frac{1}{2}(y-out)^2 $</p><p>先计算输出层权重矩阵w1，如果我们想知道w1对整体误差产生了多少影响，可以用整体误差对w1求偏导求出：（链式法则）</p><p>$\frac{dE}{dw_1} = \frac{dE}{dout}\ast\frac{dout}{dnet_o}\ast\frac{dnet_o}{dw_1}$</p><p>分别计算上面的每一项</p><p>$\frac{dE}{dout} = -(y-out)$</p><p>$\frac{dout}{dnet_o} = out(1-out)$   这一项就是sigmoid的导数</p><p>$\frac{dnet_o}{dw_1}=out_h$ 这一项就是隐含层的输出结果</p><p>为了表达方便，$\delta_o$用来表示输出层的误差:</p><p>$\delta=\frac{dE}{dout}*\frac{dout}{dnet_o}=\frac{dE}{dnet_o}$</p><p>最终的结果可以简化为</p><p>$\frac{dE}{dw_1}=\delta_o*out_h$</p><p>最后我们来更新w1的值:</p><p>$w_1 =w_1-\eta\ast\frac{dE}{dw_1} $</p><p>现在让我们回过头来看看代码<br>layer2_delta = (layer2 - y)* (layer2*(1-layer2))<br>layer2_delta正是在计算$\delta_0$<br>w1 -= (lr * layer1.T.dot(layer2_delta))<br>w1正是在计算$\delta_o\ast out_h$ 然后乘以学习率，在更新到原有的w1上</p><p>下面我们再来看看隐含层权重矩阵w0的更新情况</p><p>$\frac{dE}{dw_0} = \frac{dE}{dout_h}\ast\frac{dout_h}{dnet_h}\ast\frac{dnet_h}{dw_0}$</p><p>总共有三项，我们先计算第一项，将第一项展开</p><p>$\frac{dE}{dout_h}=\frac{dE}{dnet_o}\ast\frac{dnet_o}{dout_h}$</p><p>再展开$\frac{dE}{dnet_o}$</p><p>$\frac{dE}{dnet_o}=\frac{dE}{dout}\ast\frac{dout}{dnet_o}$</p><p>仔细看这两项的已经在上面计算输出层权重偏导的时候计算过了</p><p>然后我们又知道</p><p>$\frac{dnet_o}{dout_h}=w_1$</p><p>所以$\frac{dE}{dout_h}$ 这一项已经计算完成，还剩后面两项</p><p>$\frac{dout_h}{dnet_h}=out_h\ast(1-out_h)$ 这一项依旧是sigmoid的导数</p><p>最后还剩$\frac{dnet_h}{dw_0}$</p><p>$\frac{dnet_h}{dw_0}=X$ 这一项就是输入X</p><p>最后我们将3项相乘,可以得到结果<br>为了简化公式，用$\delta_h$表示隐含层单元的误差：<br>化简公式如下</p><p>$\frac{dE}{dw_0}=\delta_o*w_1\ast out_h(1-out_h)\ast X$</p><p>$\frac{dE}{dw_0}=\delta_h\ast X$</p><p>$w_0 =w_0-\eta\ast\frac{dE}{dw_0} $</p><p>现在我们再回到代码，看看更新w0的部分<br>layer1_delta = layer2_delta.dot(w1.T) <em> (layer1 </em> (1-layer1))<br>w0 -= (lr * X.T.dot(layer1_delta))<br>layer1_delta正是在计算$\delta_h$<br>最终再乘以学习率，完成对隐含层权重w0的更新</p><p>以上就是全部的反向传播计算过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概要&quot;&gt;&lt;a href=&quot;#1-概要&quot; class=&quot;headerlink&quot; title=&quot;1.概要&quot;&gt;&lt;/a&gt;1.概要&lt;/h2&gt;&lt;p&gt;本文来自博客 &lt;a href=&quot;http://iamtrask.github.io/2015/07/27/python-network-part2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A Neural Network in 13 lines of Python&lt;/a&gt;&lt;br&gt;这篇博客只用了13行代码就实现了Python版本的反向传播，虽然有很多文章都对它进行了翻译，但在最关键反向传播部分，并没有给出详细公式，下面就对代码中的反向传播进行重点介绍。&lt;/p&gt;
&lt;h2 id=&quot;2-全部反向传播代码&quot;&gt;&lt;a href=&quot;#2-全部反向传播代码&quot; class=&quot;headerlink&quot; title=&quot;2.全部反向传播代码&quot;&gt;&lt;/a&gt;2.全部反向传播代码&lt;/h2&gt;&lt;p&gt;下面是13行完整代码&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X = np.array([ [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] ])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = np.array([[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]]).T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lr,hidden_dim = (&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;w0 = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;*np.random.random((&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,hidden_dim)) - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;w1 = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;*np.random.random((hidden_dim,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)) - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;60000&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer1 = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;/(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;+np.exp(-(np.dot(X,w0))))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer2 = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;/(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;+np.exp(-(np.dot(layer1,w1))))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer2_delta = (layer2 - y)*(layer2*(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;-layer2))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer1_delta = layer2_delta.dot(w1.T) * (layer1 * (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;-layer1))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    w1 -= (lr * layer1.T.dot(layer2_delta))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    w0 -= (lr * X.T.dot(layer1_delta))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(layer2)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-关键行解释&quot;&gt;&lt;a href=&quot;#3-关键行解释&quot; class=&quot;headerlink&quot; title=&quot;3.关键行解释&quot;&gt;&lt;/a&gt;3.关键行解释&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;变量&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;定义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;X&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;输入数据矩阵，每行是一个训练样例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;y&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;输出数据矩阵，每行是一个训练样例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;layer1&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;神经网络的隐含层，输入来自X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;layer2&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;神经网络的输出层，输入来自layer1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;w1&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;输出层权重，连接layer1与layer2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;w0&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;隐含层权重，连接X与layer1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;line1-6:&lt;/strong&gt; 前6行都是在定义初始化参数，学习率和权重矩阵等等，这些应该很好理解。&lt;br&gt;&lt;strong&gt;line8-9:&lt;/strong&gt; 这两行是在进行前向传播，激活函数为sigmoid。&lt;br&gt;&lt;strong&gt;line10-13:&lt;/strong&gt; 这四行是在进行反向传播，下面来说说代码为什么这么写&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://kommmy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="python" scheme="https://kommmy.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>django.conf.settings的注意事项</title>
    <link href="https://kommmy.github.io/2018/03/22/djangoconf/"/>
    <id>https://kommmy.github.io/2018/03/22/djangoconf/</id>
    <published>2018-03-22T10:01:46.000Z</published>
    <updated>2018-03-22T10:18:05.603Z</updated>
    
    <content type="html"><![CDATA[<p>因为在settings中加了自定义配置项，但是用django.conf.settings却无论如何都加载不到，还好在下面找到了答案。<br><a href="https://stackoverflow.com/questions/8780756/django-difference-between-import-django-conf-settings-and-import-settings" target="_blank" rel="noopener">https://stackoverflow.com/questions/8780756/django-difference-between-import-django-conf-settings-and-import-settings</a><br>总而言之，如果你想通过django.conf.settings加载你的自定义配置，请务必在settings.py中将你的配置全部大写！<br>毕竟在源码中这么写的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 你的配置项</span></span><br><span class="line">mod = importlib.import_module(self.SETTINGS_MODULE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> setting <span class="keyword">in</span> dir(mod):</span><br><span class="line">    <span class="comment"># 判断是否都是大写</span></span><br><span class="line">    <span class="keyword">if</span> setting.isupper():</span><br><span class="line">        setting_value = getattr(mod, setting)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为在settings中加了自定义配置项，但是用django.conf.settings却无论如何都加载不到，还好在下面找到了答案。&lt;br&gt;&lt;a href=&quot;https://stackoverflow.com/questions/8780756/django-differe
      
    
    </summary>
    
      <category term="编程" scheme="https://kommmy.github.io/categories/programming/"/>
    
    
      <category term="python" scheme="https://kommmy.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>小结Python中的元类Metaclass</title>
    <link href="https://kommmy.github.io/2018/03/08/metaclass/"/>
    <id>https://kommmy.github.io/2018/03/08/metaclass/</id>
    <published>2018-03-08T07:16:17.000Z</published>
    <updated>2018-03-08T07:44:54.596Z</updated>
    
    <content type="html"><![CDATA[<p>关于metaclass，不用把它想的很复杂，只要和函数的装饰器做类比就好。通俗的说，装饰器是对函数参数的预处理，metaclass是对类属性的预处理。<br>下面拿一段代码来做解释：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaClass</span><span class="params">(type)</span>:</span> <span class="comment"># to uppercase all attrs</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(mcs, class_name, class_parents, class_attr)</span>:</span></span><br><span class="line">        attrs = &#123;name <span class="keyword">if</span> name.startswith(<span class="string">'__'</span>) <span class="keyword">else</span> name.upper(): value <span class="keyword">for</span> name, value <span class="keyword">in</span> class_attr.items()&#125;</span><br><span class="line">        <span class="keyword">return</span> super().__new__(mcs, class_name, class_parents, attrs)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(metaclass=UpperAttrMetaClass)</span>:</span></span><br><span class="line">    bar = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, params)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.params = params</span><br><span class="line">base = Base(<span class="number">1</span>)</span><br><span class="line">print(base.BAR)</span><br><span class="line">print(base.bar)</span><br></pre></td></tr></table></figure></p><p>这个UpperAttrMetaClass的功能就是把目标类中的所有类属性（不包含__开头的）全部转换为大写。<br><a id="more"></a><br>执行上面的代码，可以看到最后访问base.BAR会返回1，访问base.bar会报错。<br>就是这么简单！<br>另外多说一句，上述代码是在python3以上执行的，如果是python2，需要这么写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">()</span>:</span></span><br><span class="line">    __metaclass__ = UpperAttrMetaClass</span><br><span class="line">    bar = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, params)</span>:</span></span><br><span class="line">        super(Base,self).__init__()</span><br><span class="line">        self.params = params</span><br></pre></td></tr></table></figure></p><p>可以对比下区别，如果想兼容python2，python3的metaclass写法，需要引入six库，将上面两种写法合并为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> six</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(six.with_metaclass<span class="params">(UpperAttrMetaClass)</span>)</span>:</span></span><br><span class="line">    <span class="comment"># todo</span></span><br></pre></td></tr></table></figure></p><p>参考链接<br><a href="https://stackoverflow.com/questions/49066476/python-metaclass-pass-init-params" target="_blank" rel="noopener">https://stackoverflow.com/questions/49066476/python-metaclass-pass-init-params</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于metaclass，不用把它想的很复杂，只要和函数的装饰器做类比就好。通俗的说，装饰器是对函数参数的预处理，metaclass是对类属性的预处理。&lt;br&gt;下面拿一段代码来做解释：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UpperAttrMetaClass&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(type)&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# to uppercase all attrs&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__new__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(mcs, class_name, class_parents, class_attr)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        attrs = &amp;#123;name &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; name.startswith(&lt;span class=&quot;string&quot;&gt;&#39;__&#39;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; name.upper(): value &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; name, value &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; class_attr.items()&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; super().__new__(mcs, class_name, class_parents, attrs)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Base&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(metaclass=UpperAttrMetaClass)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bar = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, params)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super().__init__()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.params = params&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;base = Base(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(base.BAR)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(base.bar)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个UpperAttrMetaClass的功能就是把目标类中的所有类属性（不包含__开头的）全部转换为大写。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://kommmy.github.io/categories/programming/"/>
    
    
      <category term="python" scheme="https://kommmy.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>浅谈python2到python3的区别</title>
    <link href="https://kommmy.github.io/2018/02/27/new/"/>
    <id>https://kommmy.github.io/2018/02/27/new/</id>
    <published>2018-02-27T07:36:09.000Z</published>
    <updated>2018-03-08T07:42:09.972Z</updated>
    
    <content type="html"><![CDATA[<p>随着numpy和django相继宣布不再支持python2.x，我想是时候进入python3.x的时代了。那么今天我们就来看看从python2到python3都有什么重大的改进。</p><h3 id="1-通过-实现矩阵乘法"><a href="#1-通过-实现矩阵乘法" class="headerlink" title="1.通过 @ 实现矩阵乘法"></a>1.通过 @ 实现矩阵乘法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">X = np.random.rand(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">W = np.random.rand(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># python2</span></span><br><span class="line">Y = W.dot(X)</span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line">Y = W @ X</span><br></pre></td></tr></table></figure><h3 id="2-类型提示-→-运行时的类型检查"><a href="#2-类型提示-→-运行时的类型检查" class="headerlink" title="2.类型提示 → 运行时的类型检查"></a>2.类型提示 → 运行时的类型检查</h3><p>python在给别人阅读时，有个最大的困扰，就是参数传递类型不明确，给读者造成很大困扰，在python3中加入了type hinting，具体操作如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(a:int,b:str)</span>-&gt;int:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>这种写法和scala的写法极其相似，也不知道是谁模仿的谁<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(a:<span class="type">Int</span>,b:<span class="type">String</span>):<span class="type">Int</span>=&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，指定了a的类型为int,b的类型是str,返回类型为int<br>但是这种写法仅仅是增加可读性，优化IDE的提示效果，如果想强制限制类型，<br>需要安装一个模块enforce<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install enforce</span><br></pre></td></tr></table></figure></p><p>具体限制方法如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@enforce.runtime_validation</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(text:str)</span>-&gt;str:</span></span><br><span class="line">    print(text)</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line">foo(<span class="string">"hi"</span>) <span class="comment"># 正确</span></span><br><span class="line">foo(<span class="number">1</span>) </span><br><span class="line"><span class="comment"># 会报RuntimeTypeError</span></span><br><span class="line"><span class="comment"># 提示 The following runtime type errors were encountered:Argument 'text' was not of type &lt;class 'str'&gt;. Actual type was int.</span></span><br></pre></td></tr></table></figure></p><p>当然，还可以限制数组里的内容，例如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> typing <span class="comment"># 导入泛型模块</span></span><br><span class="line"><span class="meta">@enforce.runtime_validation</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(text:typing.List[int])</span>-&gt;typing.List[int]:</span></span><br><span class="line">    print(text)</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line">foo([<span class="number">1</span>]) <span class="comment"># ok</span></span><br><span class="line">foo([<span class="string">'1'</span>]) <span class="comment"># 报错，提示类型错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以同时定义2个数据类型</span></span><br><span class="line">T = typing.TypeVar(<span class="string">"T"</span>,int,str)</span><br><span class="line"><span class="meta">@enforce.runtime_validation</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(text:T)</span>-&gt;T:</span></span><br><span class="line">    print(text)</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line">    </span><br><span class="line">bar(<span class="number">1</span>) <span class="comment"># ok</span></span><br><span class="line">bar(<span class="keyword">True</span>) <span class="comment"># 报错，提示类型错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以对Callable类型做显示</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(a:int,b:int)</span>-&gt;str:</span></span><br><span class="line">    <span class="keyword">return</span> str(a*b)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@enforce.runtime_validation</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a: typing.Callable[[int, int], str])</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">return</span> a(<span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">foo(test) <span class="comment"># ok 因为foo函数的参数限制了Callable类型的参数，test函数与他匹配</span></span><br></pre></td></tr></table></figure></p><h3 id="3-更丰富的解包功能"><a href="#3-更丰富的解包功能" class="headerlink" title="3.更丰富的解包功能"></a>3.更丰富的解包功能</h3><p>请看如下对比<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python2</span></span><br><span class="line">a,b,*c = [<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>]</span><br><span class="line"><span class="comment">#SyntaxError: invalid syntax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3</span></span><br><span class="line">a,b,*c = [<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>]</span><br><span class="line">print(c)</span><br><span class="line"><span class="comment">#[[3], [4]]</span></span><br></pre></td></tr></table></figure></p><h3 id="4-更加简洁的super"><a href="#4-更加简洁的super" class="headerlink" title="4.更加简洁的super"></a>4.更加简洁的super</h3><p>现在我们在调用super()的时候，已经不需要传入当前的类名和self了，只需要简单的super()即可完成！<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span><span class="params">(MySuperClass)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, **options)</span>:</span></span><br><span class="line">        super(MySubClass, self).__init__(name=<span class="string">'subclass'</span>, **options)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span><span class="params">(MySuperClass)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, **options)</span>:</span></span><br><span class="line">        super().__init__(name=<span class="string">'subclass'</span>, **options)</span><br></pre></td></tr></table></figure></p><p>参考文献<br><a href="https://github.com/kommmy/python3_with_pleasure" target="_blank" rel="noopener">https://github.com/kommmy/python3_with_pleasure</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着numpy和django相继宣布不再支持python2.x，我想是时候进入python3.x的时代了。那么今天我们就来看看从python2到python3都有什么重大的改进。&lt;/p&gt;
&lt;h3 id=&quot;1-通过-实现矩阵乘法&quot;&gt;&lt;a href=&quot;#1-通过-实现矩阵乘法&quot; class=&quot;headerlink&quot; title=&quot;1.通过 @ 实现矩阵乘法&quot;&gt;&lt;/a&gt;1.通过 @ 实现矩阵乘法&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X = np.random.rand(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;W = np.random.rand(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# python2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Y = W.dot(X)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# python3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Y = W @ X&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2-类型提示-→-运行时的类型检查&quot;&gt;&lt;a href=&quot;#2-类型提示-→-运行时的类型检查&quot; class=&quot;headerlink&quot; title=&quot;2.类型提示 → 运行时的类型检查&quot;&gt;&lt;/a&gt;2.类型提示 → 运行时的类型检查&lt;/h3&gt;&lt;p&gt;python在给别人阅读时，有个最大的困扰，就是参数传递类型不明确，给读者造成很大困扰，在python3中加入了type hinting，具体操作如下&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(a:int,b:str)&lt;/span&gt;-&amp;gt;int:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这种写法和scala的写法极其相似，也不知道是谁模仿的谁&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;/span&gt;(a:&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;,b:&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;):&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看出，指定了a的类型为int,b的类型是str,返回类型为int&lt;br&gt;但是这种写法仅仅是增加可读性，优化IDE的提示效果，如果想强制限制类型，&lt;br&gt;需要安装一个模块enforce&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://kommmy.github.io/categories/programming/"/>
    
    
      <category term="python" scheme="https://kommmy.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>解决django日志多进程写入混乱的问题</title>
    <link href="https://kommmy.github.io/2018/02/11/page/"/>
    <id>https://kommmy.github.io/2018/02/11/page/</id>
    <published>2018-02-11T03:37:32.000Z</published>
    <updated>2018-02-11T07:59:23.896Z</updated>
    
    <content type="html"><![CDATA[<p>用过django自带日志配置的人都知道logging.handlers.RotatingFileHandler功能，但是最近在项目中发现，如果uwsgi配置django启动多进程的话，即便是开启了日志滚动功能，也不能保证所有日志都会写入当前最新的日志中，这究竟是为什么呢？<br>让我们看看下面的实验<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"./1.log"</span>,<span class="string">"a"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        f.write(<span class="string">"Hello World\n"</span>,)</span><br><span class="line">        f.flush()</span><br><span class="line">        print(<span class="string">"write line"</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    p = multiprocessing.Process(target=write)</span><br><span class="line">    p.start()</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>执行脚本后我们可以看到在1.log中会有持续写入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tail -f 1.log </span></span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p><p>此时我们把1.log改名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mv 1.log 2.log</span></span><br><span class="line"><span class="comment"># tail -f 2.log </span></span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p><p>会发现2.log仍然会继续写入，因为进程得到了文件的句柄，所以就算这个文件改名为2.log了，它也会继续往2这个文件写入的。<br>这也就解释了为什么即使配置了<br>logging.handlers.RotatingFileHandler或者logging.handlers.TimedRotatingFileHandler，文件配置了切片也会写到每个进程对应的文件下面。</p><p>幸好已经有解决这个问题的模块</p><blockquote><ul><li><a href="https://pypi.python.org/pypi/ConcurrentLogHandler/0.9.1" target="_blank" rel="noopener">https://pypi.python.org/pypi/ConcurrentLogHandler/0.9.1</a></li><li><a href="https://github.com/kieslee/mlogging" target="_blank" rel="noopener">https://github.com/kieslee/mlogging</a></li></ul></blockquote><p>使用以上两个模块都可以解决问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用过django自带日志配置的人都知道logging.handlers.RotatingFileHandler功能，但是最近在项目中发现，如果uwsgi配置django启动多进程的话，即便是开启了日志滚动功能，也不能保证所有日志都会写入当前最新的日志中，这究竟是为什么呢？&lt;br&gt;让我们看看下面的实验&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#coding=utf-8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; os&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; time&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; multiprocessing&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f = open(&lt;span class=&quot;string&quot;&gt;&quot;./1.log&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        f.write(&lt;span class=&quot;string&quot;&gt;&quot;Hello World\n&quot;&lt;/span&gt;,)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        f.flush()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&quot;write line&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        time.sleep(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__==&lt;span class=&quot;string&quot;&gt;&#39;__main__&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p = multiprocessing.Process(target=write)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p.start()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://kommmy.github.io/categories/programming/"/>
    
    
      <category term="python" scheme="https://kommmy.github.io/tags/python/"/>
    
      <category term="django" scheme="https://kommmy.github.io/tags/django/"/>
    
  </entry>
  
</feed>
